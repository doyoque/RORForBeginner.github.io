{
    "docs": [
        {
            "location": "/", 
            "text": "Ruby On Rails for Absolutely Beginners\n\n\nTable of Content\n\n\n\n\nInstallation\n\n\nGetting Started\n\n\nCRUD Operations\n\n\nValidation", 
            "title": "Home"
        }, 
        {
            "location": "/#ruby-on-rails-for-absolutely-beginners", 
            "text": "", 
            "title": "Ruby On Rails for Absolutely Beginners"
        }, 
        {
            "location": "/#table-of-content", 
            "text": "Installation  Getting Started  CRUD Operations  Validation", 
            "title": "Table of Content"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nIf you prefer the official Documentation please visit \nGuides.rubyonrails.org\n.\n\n\nSetup And Install\n\n\nThis instruction will lead you to setup and install the environment of ruby programming language and ruby on rails.\n\n\nInstall dependencies\n\n\nThe first things before we install the ruby programming language, we need to download some dependencies that require for ruby. Run this command at your terminal to download and install the dependencies.\n\n\n$ sudo apt-get update\n$ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev\n\n\n\n\nrbenv\n\n\nNow the dependencies already installed. Next we need to install \nrbenv\n. This tools is using for version control of ruby installation. Which mean you can install one or more version of ruby in your computers.\n\n\n$ cd ~\n$ git clone https://github.com/rbenv/rbenv.git ~/.rbenv\n$ echo 'export PATH=\n$HOME/.rbenv/bin:$PATH\n' \n ~/.bashrc\n$ echo 'eval \n$(rbenv init -)\n' \n ~/.bashrc\n$ exec $SHELL\n\n\n\n\nruby-build\n\n\nNext install the ruby-build. Because rbenv need the \nruby-build\n for build the source of ruby code. \n\n\n$ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build\n$ echo 'export PATH=\n$HOME/.rbenv/plugins/ruby-build/bin:$PATH\n' \n ~/.bashrc\n$ exec $SHELL\n\n\n\n\nruby\n\n\nNow we can install the Ruby with \nrbenv\n. For example we install ruby with 2.4 Version.\n\n\n$ rbenv install 2.4.0\n$ rbenv global 2.4.0\n$ ruby -v\n\n\n\n\nInstall Ruby On Rails\n\n\nAfter that we install the Ruby On Rails with RubyGems. What is RubyGem? According to \nRubyGems\n - RubyGems is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries. RubyGems come alongside with Ruby installation. So when you already installed Ruby you will also have the RubyGems. Let's install the Ruby On Rails by running this command.\n\n\n$ gem install rails\n\n\n\n\nIt will download and install the Ruby On Rails. After that check the installation by typing\n\n\n$ rails --version\n$ Rails 5.2.0\n\n\n\n\nNice one. Now Ruby and Ruby On Rails are ready on your computer.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "If you prefer the official Documentation please visit  Guides.rubyonrails.org .", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#setup-and-install", 
            "text": "This instruction will lead you to setup and install the environment of ruby programming language and ruby on rails.", 
            "title": "Setup And Install"
        }, 
        {
            "location": "/installation/#install-dependencies", 
            "text": "The first things before we install the ruby programming language, we need to download some dependencies that require for ruby. Run this command at your terminal to download and install the dependencies.  $ sudo apt-get update\n$ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev", 
            "title": "Install dependencies"
        }, 
        {
            "location": "/installation/#rbenv", 
            "text": "Now the dependencies already installed. Next we need to install  rbenv . This tools is using for version control of ruby installation. Which mean you can install one or more version of ruby in your computers.  $ cd ~\n$ git clone https://github.com/rbenv/rbenv.git ~/.rbenv\n$ echo 'export PATH= $HOME/.rbenv/bin:$PATH '   ~/.bashrc\n$ echo 'eval  $(rbenv init -) '   ~/.bashrc\n$ exec $SHELL", 
            "title": "rbenv"
        }, 
        {
            "location": "/installation/#ruby-build", 
            "text": "Next install the ruby-build. Because rbenv need the  ruby-build  for build the source of ruby code.   $ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build\n$ echo 'export PATH= $HOME/.rbenv/plugins/ruby-build/bin:$PATH '   ~/.bashrc\n$ exec $SHELL", 
            "title": "ruby-build"
        }, 
        {
            "location": "/installation/#ruby", 
            "text": "Now we can install the Ruby with  rbenv . For example we install ruby with 2.4 Version.  $ rbenv install 2.4.0\n$ rbenv global 2.4.0\n$ ruby -v", 
            "title": "ruby"
        }, 
        {
            "location": "/installation/#install-ruby-on-rails", 
            "text": "After that we install the Ruby On Rails with RubyGems. What is RubyGem? According to  RubyGems  - RubyGems is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries. RubyGems come alongside with Ruby installation. So when you already installed Ruby you will also have the RubyGems. Let's install the Ruby On Rails by running this command.  $ gem install rails  It will download and install the Ruby On Rails. After that check the installation by typing  $ rails --version\n$ Rails 5.2.0  Nice one. Now Ruby and Ruby On Rails are ready on your computer.", 
            "title": "Install Ruby On Rails"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "Ruby On Rails\n\n\nGetting Started with Rails\n\n\nFirst rails app\n\n\nSo the Rails is installed but how do we get start with Rails?. Well just run \nrails new my-project\n at the terminal and Rails will generate the application files and folders for us. And don't forget you can named the application whatever you want like \nrails new blog\n but in this case we gonna name it \"my-project\".\n\n\n$ rails new my-project\n\n\n\n\nAfter that your app will created. Let's move to your app directory and look what Rails have done.\n\n\n$ cd my-project\n$ ls -l\ndrwxrwxr-x 10 root root 4096 Agu  4 13:21 app\ndrwxr-xr-x  2 root root 4096 Agu  4 13:21 bin\ndrwxrwxr-x  5 root root 4096 Agu  4 13:21 config\n-rw-rw-r--  1 root root  130 Agu  4 13:21 config.ru\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 db\n-rw-rw-r--  1 root root 2205 Agu  4 13:21 Gemfile\n-rw-rw-r--  1 root root 5293 Agu  4 13:21 Gemfile.lock\ndrwxrwxr-x  4 root root 4096 Agu  4 13:21 lib\ndrwxrwxr-x  2 root root 4096 Agu  4 13:42 log\n-rw-rw-r--  1 root root   68 Agu  4 13:21 package.json\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 public\n-rw-rw-r--  1 root root  227 Agu  4 13:21 Rakefile\n-rw-rw-r--  1 root root  374 Agu  4 13:21 README.md\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 storage\ndrwxrwxr-x  9 root root 4096 Agu  4 13:21 test\ndrwxrwxr-x  6 root root 4096 Agu  4 13:42 tmp\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 vendor\n\n\n\n\nRails working directory\n\n\nLet's take a look what the purpose of files and folders was created by Rails.\n\n\n\n\n\n\n\n\nFile/Folder\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nApp/\n\n\nContains the controllers, models, views, helpers, mailers, channels, jobs and assets for your application. You'll focus on this folder for the remainder of this guide.\n\n\n\n\n\n\nbin/\n\n\nContains the rails script that starts your app and can contain other scripts you use to setup, update, deploy or run your application.\n\n\n\n\n\n\nconfig/\n\n\nConfigure your application's routes, database, and more.\n\n\n\n\n\n\nconfig.ru\n\n\nRack configuration for Rack based servers used to start the application.\n\n\n\n\n\n\ndb/\n\n\nContains your current database schema, as well as the database migrations.\n\n\n\n\n\n\nGemfile and Gemfile.lock\n\n\nThese files allow you to specify what gem dependencies are needed for your Rails application. These files are used by the Bundler gem.\n\n\n\n\n\n\nlib/\n\n\nExtended modules for your application.\n\n\n\n\n\n\nlog/\n\n\nApplication log files.\n\n\n\n\n\n\npackage.json\n\n\nThis file allows you to specify what npm dependencies are needed for your Rails application. This file is used by Yarn.\n\n\n\n\n\n\npublic/\n\n\nThe only folder seen by the world as-is. Contains static files and compiled assets.\n\n\n\n\n\n\nRakefile\n\n\nThis file locates and loads tasks that can be run from the command line. The task definitions are defined throughout the components of Rails. Rather than changing Rakefile, you should add your own tasks by adding files to the lib/tasks directory of your application.\n\n\n\n\n\n\nREADME.md\n\n\nThis is a brief instruction manual for your application. You should edit this file to tell others what your application does, how to set it up, and so on.\n\n\n\n\n\n\ntest/\n\n\nUnit tests, fixtures, and other test apparatus.\n\n\n\n\n\n\ntmp/\n\n\nTemporary files (like cache and pid files).\n\n\n\n\n\n\nvendor/\n\n\nA place for all third-party code. In a typical Rails application this includes vendored gems.\n\n\n\n\n\n\n.gitignore\n\n\nThis file tells git which files (or patterns) it should ignore.\n\n\n\n\n\n\n.ruby-version\n\n\nThis file contains the default Ruby version.\n\n\n\n\n\n\n\n\nFor now let's keep moving on by doing a basic \"Hello world\" in Rails.\n\n\nWork around in Rails\n\n\nAs you can see we list the file and folder in working directory with \nls -l\n command. Let's try to running the application with \nrails server\n command.\n\n\n$ rails server\n=\n Booting Puma\n=\n Rails 5.2.0 application starting in development \n=\n Run `rails server -h` for more startup options\nPuma starting in single mode...\n* Version 3.12.0 (ruby 2.4.0-p0), codename: Llamas in Pajamas\n* Min threads: 5, max threads: 5\n* Environment: development\n* Listening on tcp://0.0.0.0:3000\nUse Ctrl-C to stop\n\n\n\n\nOpen your browser and navigate to \nhttp://0.0.0.0:3000\n. You should see the Rails default page.\n\n\n\n\nNow your web app is ready. But Rails is running with single static page and a default image. Let's do a basic \"hello world\" in Rails app.\n\n\n\"Hello World\" on Rails\n\n\nTo say \"Hello world\" with Rails you need to create at least a \ncontroller\n and a \nview\n.\n\n\nA controller's purpose is to receive specific requests for the application. \nRouting\n decides which controller receives which requests. And you can say a controller's is the place where application logic and algorithm is working. Often, there is more than one route to each controller, and different routes can be served by different \nactions\n. Each action's purpose is to collect information to provide it to a view.\n\n\nA view as you read is to display the information in a human readable format. The view should just display the information that come from controller. By default, view templates are written in eRuby (Embedded Ruby) which is processed by the request cycle in Rails before being sent to the user.\n\n\nTo create a new controller, you will need to run the \"controller\" generator and tell it you want a controller called \"welcome\" with an action called \"index\".\n\n\nbin/rails generate controller welcome index\n\n\n\n\nAnd Rails will create several files and a route for you.\n\n\ncreate  app/controllers/welcome_controller.rb\n route  get 'welcome/index'\ninvoke  erb\ncreate    app/views/welcome\ncreate    app/views/welcome/index.html.erb\ninvoke  test_unit\ncreate    test/controllers/welcome_controller_test.rb\ninvoke  helper\ncreate    app/helpers/welcome_helper.rb\ninvoke    test_unit\ninvoke  assets\ninvoke    coffee\ncreate      app/assets/javascripts/welcome.coffee\ninvoke    scss\ncreate      app/assets/stylesheets/welcome.scss\n\n\n\n\nThe controller is located at \napp/controllers/welcome_controller.rb\n and the view is located at \napp/views/welcome/index.html.erb\n.\n\n\nOpen the \napp/views/welcome/index.html.erb\n file in your text editor. Delete all of the existing code and replace it with single line of \"hello world\" code.\n\n\nh1\nHello, world!!\n/h1\n\n\n\n\n\nSetting the application home page\n\n\nNow that we made the controller and view. Next we need to tell Rails when we want \"Hello world\", to show up. In this case, we want it to show up when we navigate to the root URL of our site, \nhttp://0.0.0.0:3000\n. To do that, open the file \nconfig/routes.rb\n in your editor.\n\n\nRails.application.routes.draw do\n  get 'welcome/index'\n  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html\nend\n\n\n\n\nThis is your application's \nrouting\n files. The routes file is hold entries in a special DSL \ndomain-specific language\n that tells Rails how to connect incoming requests to controllers and actions. Now edit this file as below.\n\n\nRails.application.routes.draw do\n  get 'welcome/index'\n\n  root 'welcome#index'\nend\n\n\n\n\nroot 'welcome#index'\n tells Rails to map requests to the root of the application to the welcome controller's index action and \nget 'welcome/index'\n tells Rails to map requests to \nhttp://0.0.0.0:3000/welcome/index\n to the welcome controller's index action. This was created earlier when you ran the controller generator.\n\n\nNow refresh the page and you'll see the \"hello world!!\" message you put into \napp/views/welcome/index.html.erb\n.", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#ruby-on-rails", 
            "text": "", 
            "title": "Ruby On Rails"
        }, 
        {
            "location": "/gettingstarted/#getting-started-with-rails", 
            "text": "", 
            "title": "Getting Started with Rails"
        }, 
        {
            "location": "/gettingstarted/#first-rails-app", 
            "text": "So the Rails is installed but how do we get start with Rails?. Well just run  rails new my-project  at the terminal and Rails will generate the application files and folders for us. And don't forget you can named the application whatever you want like  rails new blog  but in this case we gonna name it \"my-project\".  $ rails new my-project  After that your app will created. Let's move to your app directory and look what Rails have done.  $ cd my-project\n$ ls -l\ndrwxrwxr-x 10 root root 4096 Agu  4 13:21 app\ndrwxr-xr-x  2 root root 4096 Agu  4 13:21 bin\ndrwxrwxr-x  5 root root 4096 Agu  4 13:21 config\n-rw-rw-r--  1 root root  130 Agu  4 13:21 config.ru\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 db\n-rw-rw-r--  1 root root 2205 Agu  4 13:21 Gemfile\n-rw-rw-r--  1 root root 5293 Agu  4 13:21 Gemfile.lock\ndrwxrwxr-x  4 root root 4096 Agu  4 13:21 lib\ndrwxrwxr-x  2 root root 4096 Agu  4 13:42 log\n-rw-rw-r--  1 root root   68 Agu  4 13:21 package.json\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 public\n-rw-rw-r--  1 root root  227 Agu  4 13:21 Rakefile\n-rw-rw-r--  1 root root  374 Agu  4 13:21 README.md\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 storage\ndrwxrwxr-x  9 root root 4096 Agu  4 13:21 test\ndrwxrwxr-x  6 root root 4096 Agu  4 13:42 tmp\ndrwxrwxr-x  2 root root 4096 Agu  4 13:21 vendor", 
            "title": "First rails app"
        }, 
        {
            "location": "/gettingstarted/#rails-working-directory", 
            "text": "Let's take a look what the purpose of files and folders was created by Rails.     File/Folder  Purpose      App/  Contains the controllers, models, views, helpers, mailers, channels, jobs and assets for your application. You'll focus on this folder for the remainder of this guide.    bin/  Contains the rails script that starts your app and can contain other scripts you use to setup, update, deploy or run your application.    config/  Configure your application's routes, database, and more.    config.ru  Rack configuration for Rack based servers used to start the application.    db/  Contains your current database schema, as well as the database migrations.    Gemfile and Gemfile.lock  These files allow you to specify what gem dependencies are needed for your Rails application. These files are used by the Bundler gem.    lib/  Extended modules for your application.    log/  Application log files.    package.json  This file allows you to specify what npm dependencies are needed for your Rails application. This file is used by Yarn.    public/  The only folder seen by the world as-is. Contains static files and compiled assets.    Rakefile  This file locates and loads tasks that can be run from the command line. The task definitions are defined throughout the components of Rails. Rather than changing Rakefile, you should add your own tasks by adding files to the lib/tasks directory of your application.    README.md  This is a brief instruction manual for your application. You should edit this file to tell others what your application does, how to set it up, and so on.    test/  Unit tests, fixtures, and other test apparatus.    tmp/  Temporary files (like cache and pid files).    vendor/  A place for all third-party code. In a typical Rails application this includes vendored gems.    .gitignore  This file tells git which files (or patterns) it should ignore.    .ruby-version  This file contains the default Ruby version.     For now let's keep moving on by doing a basic \"Hello world\" in Rails.", 
            "title": "Rails working directory"
        }, 
        {
            "location": "/gettingstarted/#work-around-in-rails", 
            "text": "As you can see we list the file and folder in working directory with  ls -l  command. Let's try to running the application with  rails server  command.  $ rails server\n=  Booting Puma\n=  Rails 5.2.0 application starting in development \n=  Run `rails server -h` for more startup options\nPuma starting in single mode...\n* Version 3.12.0 (ruby 2.4.0-p0), codename: Llamas in Pajamas\n* Min threads: 5, max threads: 5\n* Environment: development\n* Listening on tcp://0.0.0.0:3000\nUse Ctrl-C to stop  Open your browser and navigate to  http://0.0.0.0:3000 . You should see the Rails default page.   Now your web app is ready. But Rails is running with single static page and a default image. Let's do a basic \"hello world\" in Rails app.", 
            "title": "Work around in Rails"
        }, 
        {
            "location": "/gettingstarted/#hello-world-on-rails", 
            "text": "To say \"Hello world\" with Rails you need to create at least a  controller  and a  view .  A controller's purpose is to receive specific requests for the application.  Routing  decides which controller receives which requests. And you can say a controller's is the place where application logic and algorithm is working. Often, there is more than one route to each controller, and different routes can be served by different  actions . Each action's purpose is to collect information to provide it to a view.  A view as you read is to display the information in a human readable format. The view should just display the information that come from controller. By default, view templates are written in eRuby (Embedded Ruby) which is processed by the request cycle in Rails before being sent to the user.  To create a new controller, you will need to run the \"controller\" generator and tell it you want a controller called \"welcome\" with an action called \"index\".  bin/rails generate controller welcome index  And Rails will create several files and a route for you.  create  app/controllers/welcome_controller.rb\n route  get 'welcome/index'\ninvoke  erb\ncreate    app/views/welcome\ncreate    app/views/welcome/index.html.erb\ninvoke  test_unit\ncreate    test/controllers/welcome_controller_test.rb\ninvoke  helper\ncreate    app/helpers/welcome_helper.rb\ninvoke    test_unit\ninvoke  assets\ninvoke    coffee\ncreate      app/assets/javascripts/welcome.coffee\ninvoke    scss\ncreate      app/assets/stylesheets/welcome.scss  The controller is located at  app/controllers/welcome_controller.rb  and the view is located at  app/views/welcome/index.html.erb .  Open the  app/views/welcome/index.html.erb  file in your text editor. Delete all of the existing code and replace it with single line of \"hello world\" code.  h1 Hello, world!! /h1", 
            "title": "\"Hello World\" on Rails"
        }, 
        {
            "location": "/gettingstarted/#setting-the-application-home-page", 
            "text": "Now that we made the controller and view. Next we need to tell Rails when we want \"Hello world\", to show up. In this case, we want it to show up when we navigate to the root URL of our site,  http://0.0.0.0:3000 . To do that, open the file  config/routes.rb  in your editor.  Rails.application.routes.draw do\n  get 'welcome/index'\n  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html\nend  This is your application's  routing  files. The routes file is hold entries in a special DSL  domain-specific language  that tells Rails how to connect incoming requests to controllers and actions. Now edit this file as below.  Rails.application.routes.draw do\n  get 'welcome/index'\n\n  root 'welcome#index'\nend  root 'welcome#index'  tells Rails to map requests to the root of the application to the welcome controller's index action and  get 'welcome/index'  tells Rails to map requests to  http://0.0.0.0:3000/welcome/index  to the welcome controller's index action. This was created earlier when you ran the controller generator.  Now refresh the page and you'll see the \"hello world!!\" message you put into  app/views/welcome/index.html.erb .", 
            "title": "Setting the application home page"
        }, 
        {
            "location": "/gettingup/", 
            "text": "Rails Resources\n\n\nIn your application, you will create a new \nresource\n for doing the operational of CRUD (Create, Read, Update, and Delete). A resource is the term used for a collection of similiar objects such as articles, people or animals.\n\n\nRails provides a \nresources\n method which can be used to declare a standard \nREST\n resource. Now you need to add the \nposts resource\n to the \nconfig/routes.rb\n as below:\n\n\nRails.application.routes.draw do\n  get 'welcome/index'\n\n  resources :posts\n\n  root 'welcome#index'\n  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html\nend\n\n\n\n\n\nIf you run \nbin/rails routes\n, you'll see that it has defined routes for all the standard RESTful actions.\n\n\n$ bin/rails routes\n                   Prefix Verb   URI Pattern                                                                              Controller#Action\n            welcome_index GET    /welcome/index(.:format)                                                                 welcome#index\n                    posts GET    /posts(.:format)                                                                         posts#index\n                          POST   /posts(.:format)                                                                         posts#create\n                 new_post GET    /posts/new(.:format)                                                                     posts#new\n                edit_post GET    /posts/:id/edit(.:format)                                                                posts#edit\n                     post GET    /posts/:id(.:format)                                                                     posts#show\n                          PATCH  /posts/:id(.:format)                                                                     posts#update\n                          PUT    /posts/:id(.:format)                                                                     posts#update\n                          DELETE /posts/:id(.:format)                                                                     posts#destroy\n                     root GET    /                                                                                        welcome#index\n       rails_service_blob GET    /rails/active_storage/blobs/:signed_id/*filename(.:format)                               active_storage/blobs#show\nrails_blob_representation GET    /rails/active_storage/representations/:signed_blob_id/:variation_key/*filename(.:format) active_storage/representations#show\n       rails_disk_service GET    /rails/active_storage/disk/:encoded_key/*filename(.:format)                              active_storage/disk#show\nupdate_rails_disk_service PUT    /rails/active_storage/disk/:encoded_token(.:format)                                      active_storage/disk#update\n     rails_direct_uploads POST   /rails/active_storage/direct_uploads(.:format)                                           active_storage/direct_uploads#create\n\n\n\n\nNext you will add the ability to create new posts in your application and be able to view them.\n\n\nNew Post\n\n\nAs you can see in the rails \nbin/rails routes\n log, you can access \nhttp://0.0.0.0:3000/posts/new\n directly on browser. Go ahead and check that. Then you will get the error like this.\n\n\n\n\nThe error occurs because the route need to have a controller defined in order to serve the request. Let's generate new controller called \nPostsController\n to solve the error.\n\n\nCreate the PostController\n\n\nTo generate the controller, simply do a command as below.\n\n\n$ bin/rails genereate controller Posts\n\n\n\n\nNow open the Posts controller at \napp/controllers/posts_controller.rb\n, you'll see a empty controller.\n\n\nclass PostsController \n ApplicationController\nend\n\n\n\n\nThe controller is created. Go refresh the \nhttp://0.0.0.0:3000/posts/new\n URL and you will get the error again.\n\n\n\n\nThis error indicates that Rails cannot find the \"new\" action. What is \"new\" action mean?. In Rails you just generate a controller that named \nPostsController\n. And Ruby is \nObject Oriented Programming\n Which mean you'll code with OOP concept like class, method, and many \"Object Oriented\" concept. And the error that you saw before mean Rails cannot find the 'new' action or you can say 'method' in the \nPostsController\n class.\n\n\nDefine new method\n\n\nFor the first try, let's create a new method called 'new' inside the \nposts_controller.rb\n class.\n\n\nclass PostsController \n ApplicationController\n  def new\n  end\nend\n\n\n\n\nRefresh the page and you'll get the error again.\n\n\n\n\nYou're get alot of error. Let's go through and understand what each part of it means.\n\n\nThe first part identifies which templates is missing. In this case, it's the \nposts/new\n templates. Rails will first look for this template. If not found, then it will attempt to load a template called \napplication/new\n because the \nPostsController\n is inherites from \nApplicationController\n.\n\n\nThe next part of the message contains request.formats which specifies the format of template to be served in response. It is set to \ntext/html\n as we requested this page via browser, so Rails is looking for an HTML template.\n\n\nCreate new form\n\n\nLet's create a file \nnew.html.erb\n views for \nPostsController\n at \napp/views/posts\n, And write this content in it.\n\n\nh1\nNew Posts\n/h1\n\n\n\n%= form_with scope: :article, local: true do |form| %\n\n  \np\n\n    \n%= form.label :title %\nbr\n\n    \n%= form.text_field :title %\n\n  \n/p\n\n\n  \np\n\n    \n%= form.label :text %\nbr\n\n    \n%= form.text_area :text %\n\n  \n/p\n\n\n  \np\n\n    \n%= form.submit %\n\n  \n/p\n\n\n% end %\n\n\n\n\n\nAs you can see, you will use a \nform builder\n. The primary form builder for Rails is provided by a helper method \nform_with\n. If you refresh the page now, you'll see the form is displaying sucessfuly. There's the one problem with this form though. If you inspect the HTML that is generated, by viewing the source of the page, you will see that the \naction\n attribute for the form is pointing at \n/posts/new\n. This is a problem because this routes goes to the very page that you're on right at the moment, and that route should only be used to display the form for a new post.\n\n\nThe form needs to use different URL in order to go somewhere else. This can be done with \n:url\n option of \nform_with\n. Edit the \nform_with\n line inside \napp/views/posts/new.html.erb\n.\n\n\n%= form_with scope: :article, url: posts_path, local: true do |form| %\n\n\n\n\n\nIn this example, the \nposts_path\n helper is passed to the \n:url\n option. In this case, helper tells the Rails to point the form to the URI Pattern associated with the \nposts\n prefix. And the form will (by default) send a \nPOST\n request to that routes. You can check the URL Pattern by running this command.\n\n\n$ bin/rails routes\n\n\n\n\nIt will generated a list of the URI that same as \nabove\n.\n\n\nAfter that go fill up the form and submit that. You'll get this error.\n\n\n\n\nThe error is very meaningful as before. That mean Rails can't find \ncreate\n method at your \nposts_controller.rb\n.\n\n\nDefine create method\n\n\nSame as before. Let's create a new method called \ncreate\n inside the \nPostsController\n class.\n\n\nclass PostsController \n ApplicationController\n\n  def create\n    render plain: params[:post].inspect\n  end\n\nend\n\n\n\n\n\nThe \nrender\n method here is taking a very simple hash with a key of \n:plain\n and value of \nparams[:posts]\n.inspect. The params method is the object which represents the parameters (or fields) coming in from the form. The params method returns an \nActionController::Parameters\n object, which allows you to access the keys of the hash using either strings or symbols. In this situation, the only parameters that matter are the ones from the form.\n\n\nIf you submit the form, you'll see something like this\n\n\nActionController::Parameters {\ntitle\n=\nasdf\n, \ntext\n=\nasdfasd asdf asdf asdfafsdf\n} permitted: false\n\n\n\n\n\nThis action is now displaying the parameters for the article that are coming in from the form. But this is not really all that helpful.\n\n\nModel for post\n\n\nWhen you create a \ncreate\n action, this mean you create the data and store it to database. But this will never get done if you never created the Database, right?. So how to create the DB?. The good news is, Rails come with sqlite3 as the default DB. Simply run this command at your terminal and Rails will do the rest for us.\n\n\n$ bin/rails generate model Post title:string text:text\n\n\n\n\nWhat that command mean is we told Rails \nPost\n model, together with \ntitle\n attribute of type string, and a \ntext\n attribute of type text.\n\n\nSo far we talk about \nmodel\n, \nview\n, and \ncontroller\n. And that's make sense, it because Ruby On Rails is working with architectural pattern commonly known as \nMVC\n Which is \nmodel\n is represents the data structure. It is the application's dynamic data structure, independent of the user interface. It directly manages the data, logic and rules of the application.\n\n\nRails responded by creating a bunch of files. For now, we are only take a look in \napp/models/post.rb\n and \ndb/migrate/20180806092757_create_posts.rb\n\n\nRun the migration\n\n\nBefore run the migration, let's take a look at \ndb/migrate/20180806092757_create_posts.rb\n\n\nclass CreatePosts \n ActiveRecord::Migration[5.2]\n  def change\n    create_table :posts do |t|\n      t.string :title\n      t.text :text\n\n      t.timestamps\n    end\n  end\nend\n\n\n\n\n\nThe above migration creates as a method named \nchange\n which will be called when you run this migration. It will create table named \nposts\n with one string \ntitle\n column and a \ntext\n column after you run the migration.\n\n\nNow run the migration command just like this.\n\n\n$ bin/rails db:migrate\n\n\n\n\nRails will execute this migration command and tell you it created the Posts table.\n\n\n== 20180806092757 CreatePosts: migrating ======================================\n-- create_table(:posts)                                                        \n   -\n 0.0031s                                                                  \n== 20180806092757 CreatePosts: migrated (0.0032s) =============================\n\n\n\n\nSaving data in the controller\n\n\nNow the model is migrated. Let's edit the \nposts_controller.rb\n. We need to edit \ncreate\n method as below.\n\n\nclass PostsController \n ApplicationController\n\n  def create\n    @post = Post.new(params[:post])\n\n    @post.save\n    redirect_to @post\n  end\n\nend\n\n\n\n\nHere's what's going on: In the first line we add the data in \nPost\n table with \n.new()\n function using the parameter from request that carry on with \nparams[:post]\n. \n@post\n it's a instance variable and is available to all methods within the class. Then \n@post.save\n is responsible for saving the model in the database and after that we redirect the user to \nshow\n action.\n\n\nNow let's try to add the new post by access \nhttp://0.0.0.0:3000/posts/new\n and fill up the form. Go submit the form and you will get error like this.\n\n\n\n\nSecure the paramters\n\n\nRails has several security features that help you write secure applications, and you're running into one of them now. This one is called strong parameters, which requires us to tell Rails exactly which parameters are allowed into our controller actions. If don't secure the paramters that come from submit request, It very dangerous because it might be contain extra filed with values that violated your application's integrity. They would be 'mass assigned' into your model and then into the database along with the good stuff - potentially breaking your application.\n\n\nWe have to whitelist our controller parameters to prevent wrongful mass assigment. In this case, we want to both allow and require the \ntitle\n and \ntext\n parameters for vaild of \ncreate\n.\n\n\nclass PostsController \n ApplicationController\n\n  def create\n    @post = Post.new(post_params)\n\n    @post.save\n    redirect_to @post\n  end\n\n  private\n    def post_params\n      params.require(:post).permit(:title,:text)\n    end\n\nend\n\n\n\n\nThis is often factored out into its own method so it can be reused by multiple actions in the same controller, for example \ncreate\n and \nupdate\n. The method is often made \nprivate\n to make sure it can't be called outside its intended context.\n\n\nShow Post\n\n\nIf you try to submit the form, Rails will complain about not finding \nshow\n action. And if you take a look the URL, it looks like \nhttp://0.0.0.0:3000/posts/1\n which mean after you submit the form it will navigate to \n/posts/:id/\n URI. \n\n\nDefine show method\n\n\nSame as \nnew post\n (but without model and migration), you need to create correspondent method and view to display the information. Let's create the \nshow\n method first.\n\n\n  def show\n    @post = Post.find(params[:id])\n  end\n\n\n\n\nThings to note. We use \nPost.find\n to find the article we're interested in, passing in \nparams[:id]\n to get the \n:id\n parameter from the request. Then we'll use instance variable (prefixed with \n@\n) to hold a reference to post object and pass the instance to the view.\n\n\nCreate show file\n\n\nNow, create file named \nshow.html.erb\n in \napp/views/posts/\n with the following content\n\n\nh1\nShow The Post\n/h1\n\n\np\n\n  \nstrong\nTitle:\n/strong\n\n  \n%= @post.title %\n\n\n/p\n\n\n\np\n\n  \nstrong\nText:\n/strong\n\n  \n%= @post.text %\n\n\n/p\n\n\n\n\n\nAnd after you submit the form, You'll see the post has been sucessfuly to display.\n\n\n\n\nList All Post\n\n\nSo far we just created \nnew\n and \nshow\n. But how does we see all these data in one page?. We need to list all our posts, so let's do that by creating \nindex\n method in \nposts_controller.rb\n.\n\n\nclass PostsController \n ApplicationController\n\n  def index\n    @post = Post.all\n  end\n\n  #above 'new' method\nend\n\n\n\n\nAnd create new file named \nindex\n at \napp/views/posts/index.html.erb\n.\n\n\nh1\nListing Posts\n/h1\n\n\n\ntable\n\n  \ntr\n\n    \nth\nTitle\n/th\n\n    \nth\nText\n/th\n\n    \nth\n/th\n\n  \n/tr\n\n\n  \n% @post.each do |posts| %\n\n    \ntr\n\n      \ntd\n%= posts.title %\n/td\n\n      \ntd\n%= posts.text %\n/td\n\n      \ntd\n%= link_to 'Show', post_path(posts) %\n/td\n\n    \n/tr\n\n  \n% end %\n\n\n/table\n\n\n\n\n\nThen navigate browser to \nhttp://0.0.0.0:3000/posts\n You'll see all the post are listed in table with the link to show the post.\n\n\n\n\nAdd link\n\n\nBut we missed a simple thing. We need to add a link to \n/posts\n view in the root of page. So when user navigate to \nhttp://0.0.0.0:3000\n, It will contain a link to \n/posts\n.\n\n\nOpen \napp/views/welcome/index.html.erb\n and add the link.\n\n\nh1\nHello, world!!\n/h1\n\n\n%= link_to 'My Post', controller: 'posts' %\n\n\n\n\n\nThe \nlink_to\n method is one of Rails built-in view helpers. It create hyperlink based on text to display and where to go.\n\n\nNext add another link called \"New Post\" in \napp/viewws/posts/index.html.erb\n placing it above the \ntable\n tag.\n\n\n%= link_to 'New Post', new_post_path %\n\n\n\n\n\nNow give a link to back to \n/posts\n URL in \napp/views/posts/new.html.erb\n in the bottom of the code.\n\n\nh1\nnew Post\n/h1\n\n\n\n%= form_with scope: :post, url: posts_path, local: true do |f|%\n\n\np\n\n  \n%= f.label :title %\nbr\n\n  \n%= f.text_field :title %\n\n\n/p\n\n\n\np\n\n  \n%= f.label :text %\nbr\n\n  \n%= f.text_area :text %\n\n\n/p\n\n\n\np\n\n  \n%= f.submit %\n\n\n/p\n\n\n% end %\n\n\n\n%= link_to 'Back', posts_path %\n\n\n\n\n\nAnd finally add another link to go back to posts index in \napp/views/posts/show.html.erb\n.\n\n\nh1\nShow The Post\n/h1\n\n\np\n\n  \nstrong\nTitle:\n/strong\n\n  \n%= @post.title %\n\n\n/p\n\n\n\np\n\n  \nstrong\nText:\n/strong\n\n  \n%= @post.text %\n\n\n/p\n\n\n\n%= link_to 'Back', posts_path %\n\n\n\n\n\nUpdate a Post\n\n\nGreat. We've covered \"CR\" in the CRUD. Now let's focus on \"U\" part.\n\n\nDefine edit method\n\n\nThe first step is of course to add new method called \nedit\n in \nPostsController\n. We named it \nedit\n as the action that covered the URI pattern. Let's show the routes list again for reminder.\n\n\n$ bin/rails routes\n                   Prefix Verb   URI Pattern                                                                              Controller#Action\n            welcome_index GET    /welcome/index(.:format)                                                                 welcome#index\n                    posts GET    /posts(.:format)                                                                         posts#index\n                          POST   /posts(.:format)                                                                         posts#create\n                 new_post GET    /posts/new(.:format)                                                                     posts#new\n                edit_post GET    /posts/:id/edit(.:format)                                                                posts#edit\n                     post GET    /posts/:id(.:format)                                                                     posts#show\n                          PATCH  /posts/:id(.:format)                                                                     posts#update\n                          PUT    /posts/:id(.:format)                                                                     posts#update\n                          DELETE /posts/:id(.:format)                                                                     posts#destroy\n                     root GET    /                                                                                        welcome#index\n       rails_service_blob GET    /rails/active_storage/blobs/:signed_id/*filename(.:format)                               active_storage/blobs#show\nrails_blob_representation GET    /rails/active_storage/representations/:signed_blob_id/:variation_key/*filename(.:format) active_storage/representations#show\n       rails_disk_service GET    /rails/active_storage/disk/:encoded_key/*filename(.:format)                              active_storage/disk#show\nupdate_rails_disk_service PUT    /rails/active_storage/disk/:encoded_token(.:format)                                      active_storage/disk#update\n     rails_direct_uploads POST   /rails/active_storage/direct_uploads(.:format)                                           active_storage/direct_uploads#create\n\n\n\n\nYou can see at \nController#Action\n column it must be \nedit\n. Let's create the action now.\n\n\nclass PostsController \n ApplicationController\n  def edit\n    @posts = Post.find(params[:id])\n  end\nend\n\n\n\n\nCreate edit file\n\n\nAnd create new file named \nedit.html.erb\n in \napp/views/posts/\n and make it look as follows:\n\n\nh1\nEdit Post\n/h1\n\n\n\n%= form_with(model: @post, local: true) do |form| %\n\n\n  \np\n\n    \n%= form.label :title %\nbr\n\n    \n%= form.text_field :title %\n\n  \n/p\n\n\n  \np\n\n    \n%= form.label :text %\nbr\n\n    \n%= form.text_area :text %\n\n  \n/p\n\n\n  \np\n\n    \n%= form.submit %\n\n  \n/p\n\n\n\n% end %\n\n\n\n%= link_to 'Back', articles_path %\n\n\n\n\n\nThe view contain a form similiar to the one we used to create new post. This time we point the form to the \nupdate\n action, which is not defined yet but will be very soon.\n\n\nPassing the article object to the method, will automagically create url for submitting the edited post form. This option tells Rails that we want this form to be submitted via the PATCH HTTP method which is the HTTP method you're expected to use to update resources according to the REST protocol.\n\n\nThe arguments to \nform_with\n could be model objects, say, \nmodel: @article\n which would cause the helper to fill in the form with the fields of the object. Passing in a symbol \nscope\n (\nscope: :article\n) just creates the fields but without anything filled into them.\n\n\nAnd don't forget to add the \nupdate\n link in \nshow\n and \nindex\n page.\n\n\nh1\nShow The Post\n/h1\n\n\np\n\n  \nstrong\nTitle:\n/strong\n\n  \n%= @post.title %\n\n\n/p\n\n\n\np\n\n  \nstrong\nText:\n/strong\n\n  \n%= @post.text %\n\n\n/p\n\n\n\n%= link_to 'Edit', edit_post_path(@post) %\n |\n\n%= link_to 'Back', posts_path %\n\n\n\n\n\nfor \nindex\n you can add link after \nshow\n link insert \ntd\n tag.\n\n\ntd\n%= link_to 'Edit', edit_post_path(posts) %\n/td\n\n\n\n\n\nDefine update method\n\n\nAfter that you must create \nupdate\n method.\n\n\n  def update\n    @post = Post.find(params[:id])\n\n    if @post.update(post_params)\n      redirect_to @post\n    else\n      render 'edit'\n    end\n  end\n\n\n\n\nThe new method \nupdate\n, is used when you want to update a record that already exists and it accepts a hash containing the attributes that you want to update. As before, if there was an error updating the article we want to show the form back to user. If you noticed that, we reuse \npost_params\n method that we defined earlier for create action.\n\n\nAfter that you'll look your app like this.\n\n\n\nDelete Post\n\n\nSo far we just created \"C\", \"R\", and \"U\". The last is the \"D\" AKA Delete. Why we need to delete the post that already created?. Because CRUD is a basic practical method for web development. And the data sometime is growing much bigger than before so we need to delete some data that no longer used.\n\n\nDefine delete and add action\n\n\nFollowing the REST convention, the route for deleting posts as per output of \nbin/rails routes\n is\n\n\nDELETE /posts/:id(.:format) posts#destroy\n\n\n\n\nthe \ndelete\n routing method should be used for routes that destroy the resources. We use the \ndelete\n method for destroying resources, and this route is mapped to the \ndestroy\n action inside \napp/controllers/posts_controller.rb\n. Let's create it now at the top of private method.\n\n\n  def destroy\n    @post = Post.find(params[:id])\n    @post.destroy\n\n    redirect_to @post\n  end\n\n\n\n\nNow call \ndestroy\n on Active Record objects when you want to delete them from the database. We dont need to add a view for this action since we're redirecting to the \nindex\n action.\n\n\nAdd 'Destroy' link to your \nindex\n template. Add it wrapped wtith \ntd\n tag and below the \nedit\n link.\n\n\nh1\nListing Posts\n/h1\n\n\n\n%= link_to 'New Post', new_post_path %\n\n\n\ntable\n\n  \ntr\n\n    \nth\nTitle\n/th\n\n    \nth\nText\n/th\n\n    \nth\n/th\n\n  \n/tr\n\n\n  \n% @post.each do |posts| %\n\n    \ntr\n\n      \ntd\n%= posts.title %\n/td\n\n      \ntd\n%= posts.text %\n/td\n\n      \ntd\n%= link_to 'Show', post_path(posts) %\n/td\n\n      \ntd\n%= link_to 'Edit', edit_post_path(posts) %\n/td\n\n      \ntd\n%= link_to 'Destroy', post_path(posts),\n              method: :delete,\n              data: { confirm: 'Are you sure?' } %\n/td\n\n    \n/tr\n\n  \n% end %\n\n\n/table\n\n\n\n\n\nThe \ndelete\n link is little bit different. The \nmethod: :delete\n and \ndata: { confirm: 'Are you sure?' }\n options are used as HTML5 attributes so, when the link is clicked, Rails will first show the confirm message to the user, and then submit the link with method \ndelete\n.\n\n\nGood work. You finised the CRUD operation in this section.", 
            "title": "CRUD Operations"
        }, 
        {
            "location": "/gettingup/#rails-resources", 
            "text": "In your application, you will create a new  resource  for doing the operational of CRUD (Create, Read, Update, and Delete). A resource is the term used for a collection of similiar objects such as articles, people or animals.  Rails provides a  resources  method which can be used to declare a standard  REST  resource. Now you need to add the  posts resource  to the  config/routes.rb  as below:  Rails.application.routes.draw do\n  get 'welcome/index'\n\n  resources :posts\n\n  root 'welcome#index'\n  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html\nend  If you run  bin/rails routes , you'll see that it has defined routes for all the standard RESTful actions.  $ bin/rails routes\n                   Prefix Verb   URI Pattern                                                                              Controller#Action\n            welcome_index GET    /welcome/index(.:format)                                                                 welcome#index\n                    posts GET    /posts(.:format)                                                                         posts#index\n                          POST   /posts(.:format)                                                                         posts#create\n                 new_post GET    /posts/new(.:format)                                                                     posts#new\n                edit_post GET    /posts/:id/edit(.:format)                                                                posts#edit\n                     post GET    /posts/:id(.:format)                                                                     posts#show\n                          PATCH  /posts/:id(.:format)                                                                     posts#update\n                          PUT    /posts/:id(.:format)                                                                     posts#update\n                          DELETE /posts/:id(.:format)                                                                     posts#destroy\n                     root GET    /                                                                                        welcome#index\n       rails_service_blob GET    /rails/active_storage/blobs/:signed_id/*filename(.:format)                               active_storage/blobs#show\nrails_blob_representation GET    /rails/active_storage/representations/:signed_blob_id/:variation_key/*filename(.:format) active_storage/representations#show\n       rails_disk_service GET    /rails/active_storage/disk/:encoded_key/*filename(.:format)                              active_storage/disk#show\nupdate_rails_disk_service PUT    /rails/active_storage/disk/:encoded_token(.:format)                                      active_storage/disk#update\n     rails_direct_uploads POST   /rails/active_storage/direct_uploads(.:format)                                           active_storage/direct_uploads#create  Next you will add the ability to create new posts in your application and be able to view them.", 
            "title": "Rails Resources"
        }, 
        {
            "location": "/gettingup/#new-post", 
            "text": "As you can see in the rails  bin/rails routes  log, you can access  http://0.0.0.0:3000/posts/new  directly on browser. Go ahead and check that. Then you will get the error like this.   The error occurs because the route need to have a controller defined in order to serve the request. Let's generate new controller called  PostsController  to solve the error.", 
            "title": "New Post"
        }, 
        {
            "location": "/gettingup/#create-the-postcontroller", 
            "text": "To generate the controller, simply do a command as below.  $ bin/rails genereate controller Posts  Now open the Posts controller at  app/controllers/posts_controller.rb , you'll see a empty controller.  class PostsController   ApplicationController\nend  The controller is created. Go refresh the  http://0.0.0.0:3000/posts/new  URL and you will get the error again.   This error indicates that Rails cannot find the \"new\" action. What is \"new\" action mean?. In Rails you just generate a controller that named  PostsController . And Ruby is  Object Oriented Programming  Which mean you'll code with OOP concept like class, method, and many \"Object Oriented\" concept. And the error that you saw before mean Rails cannot find the 'new' action or you can say 'method' in the  PostsController  class.", 
            "title": "Create the PostController"
        }, 
        {
            "location": "/gettingup/#define-new-method", 
            "text": "For the first try, let's create a new method called 'new' inside the  posts_controller.rb  class.  class PostsController   ApplicationController\n  def new\n  end\nend  Refresh the page and you'll get the error again.   You're get alot of error. Let's go through and understand what each part of it means.  The first part identifies which templates is missing. In this case, it's the  posts/new  templates. Rails will first look for this template. If not found, then it will attempt to load a template called  application/new  because the  PostsController  is inherites from  ApplicationController .  The next part of the message contains request.formats which specifies the format of template to be served in response. It is set to  text/html  as we requested this page via browser, so Rails is looking for an HTML template.", 
            "title": "Define new method"
        }, 
        {
            "location": "/gettingup/#create-new-form", 
            "text": "Let's create a file  new.html.erb  views for  PostsController  at  app/views/posts , And write this content in it.  h1 New Posts /h1  %= form_with scope: :article, local: true do |form| % \n   p \n     %= form.label :title % br \n     %= form.text_field :title % \n   /p \n\n   p \n     %= form.label :text % br \n     %= form.text_area :text % \n   /p \n\n   p \n     %= form.submit % \n   /p  % end %   As you can see, you will use a  form builder . The primary form builder for Rails is provided by a helper method  form_with . If you refresh the page now, you'll see the form is displaying sucessfuly. There's the one problem with this form though. If you inspect the HTML that is generated, by viewing the source of the page, you will see that the  action  attribute for the form is pointing at  /posts/new . This is a problem because this routes goes to the very page that you're on right at the moment, and that route should only be used to display the form for a new post.  The form needs to use different URL in order to go somewhere else. This can be done with  :url  option of  form_with . Edit the  form_with  line inside  app/views/posts/new.html.erb .  %= form_with scope: :article, url: posts_path, local: true do |form| %   In this example, the  posts_path  helper is passed to the  :url  option. In this case, helper tells the Rails to point the form to the URI Pattern associated with the  posts  prefix. And the form will (by default) send a  POST  request to that routes. You can check the URL Pattern by running this command.  $ bin/rails routes  It will generated a list of the URI that same as  above .  After that go fill up the form and submit that. You'll get this error.   The error is very meaningful as before. That mean Rails can't find  create  method at your  posts_controller.rb .", 
            "title": "Create new form"
        }, 
        {
            "location": "/gettingup/#define-create-method", 
            "text": "Same as before. Let's create a new method called  create  inside the  PostsController  class.  class PostsController   ApplicationController\n\n  def create\n    render plain: params[:post].inspect\n  end\n\nend  The  render  method here is taking a very simple hash with a key of  :plain  and value of  params[:posts] .inspect. The params method is the object which represents the parameters (or fields) coming in from the form. The params method returns an  ActionController::Parameters  object, which allows you to access the keys of the hash using either strings or symbols. In this situation, the only parameters that matter are the ones from the form.  If you submit the form, you'll see something like this  ActionController::Parameters { title = asdf ,  text = asdfasd asdf asdf asdfafsdf } permitted: false   This action is now displaying the parameters for the article that are coming in from the form. But this is not really all that helpful.", 
            "title": "Define create method"
        }, 
        {
            "location": "/gettingup/#model-for-post", 
            "text": "When you create a  create  action, this mean you create the data and store it to database. But this will never get done if you never created the Database, right?. So how to create the DB?. The good news is, Rails come with sqlite3 as the default DB. Simply run this command at your terminal and Rails will do the rest for us.  $ bin/rails generate model Post title:string text:text  What that command mean is we told Rails  Post  model, together with  title  attribute of type string, and a  text  attribute of type text.  So far we talk about  model ,  view , and  controller . And that's make sense, it because Ruby On Rails is working with architectural pattern commonly known as  MVC  Which is  model  is represents the data structure. It is the application's dynamic data structure, independent of the user interface. It directly manages the data, logic and rules of the application.  Rails responded by creating a bunch of files. For now, we are only take a look in  app/models/post.rb  and  db/migrate/20180806092757_create_posts.rb", 
            "title": "Model for post"
        }, 
        {
            "location": "/gettingup/#run-the-migration", 
            "text": "Before run the migration, let's take a look at  db/migrate/20180806092757_create_posts.rb  class CreatePosts   ActiveRecord::Migration[5.2]\n  def change\n    create_table :posts do |t|\n      t.string :title\n      t.text :text\n\n      t.timestamps\n    end\n  end\nend  The above migration creates as a method named  change  which will be called when you run this migration. It will create table named  posts  with one string  title  column and a  text  column after you run the migration.  Now run the migration command just like this.  $ bin/rails db:migrate  Rails will execute this migration command and tell you it created the Posts table.  == 20180806092757 CreatePosts: migrating ======================================\n-- create_table(:posts)                                                        \n   -  0.0031s                                                                  \n== 20180806092757 CreatePosts: migrated (0.0032s) =============================", 
            "title": "Run the migration"
        }, 
        {
            "location": "/gettingup/#saving-data-in-the-controller", 
            "text": "Now the model is migrated. Let's edit the  posts_controller.rb . We need to edit  create  method as below.  class PostsController   ApplicationController\n\n  def create\n    @post = Post.new(params[:post])\n\n    @post.save\n    redirect_to @post\n  end\n\nend  Here's what's going on: In the first line we add the data in  Post  table with  .new()  function using the parameter from request that carry on with  params[:post] .  @post  it's a instance variable and is available to all methods within the class. Then  @post.save  is responsible for saving the model in the database and after that we redirect the user to  show  action.  Now let's try to add the new post by access  http://0.0.0.0:3000/posts/new  and fill up the form. Go submit the form and you will get error like this.", 
            "title": "Saving data in the controller"
        }, 
        {
            "location": "/gettingup/#secure-the-paramters", 
            "text": "Rails has several security features that help you write secure applications, and you're running into one of them now. This one is called strong parameters, which requires us to tell Rails exactly which parameters are allowed into our controller actions. If don't secure the paramters that come from submit request, It very dangerous because it might be contain extra filed with values that violated your application's integrity. They would be 'mass assigned' into your model and then into the database along with the good stuff - potentially breaking your application.  We have to whitelist our controller parameters to prevent wrongful mass assigment. In this case, we want to both allow and require the  title  and  text  parameters for vaild of  create .  class PostsController   ApplicationController\n\n  def create\n    @post = Post.new(post_params)\n\n    @post.save\n    redirect_to @post\n  end\n\n  private\n    def post_params\n      params.require(:post).permit(:title,:text)\n    end\n\nend  This is often factored out into its own method so it can be reused by multiple actions in the same controller, for example  create  and  update . The method is often made  private  to make sure it can't be called outside its intended context.", 
            "title": "Secure the paramters"
        }, 
        {
            "location": "/gettingup/#show-post", 
            "text": "If you try to submit the form, Rails will complain about not finding  show  action. And if you take a look the URL, it looks like  http://0.0.0.0:3000/posts/1  which mean after you submit the form it will navigate to  /posts/:id/  URI.", 
            "title": "Show Post"
        }, 
        {
            "location": "/gettingup/#define-show-method", 
            "text": "Same as  new post  (but without model and migration), you need to create correspondent method and view to display the information. Let's create the  show  method first.    def show\n    @post = Post.find(params[:id])\n  end  Things to note. We use  Post.find  to find the article we're interested in, passing in  params[:id]  to get the  :id  parameter from the request. Then we'll use instance variable (prefixed with  @ ) to hold a reference to post object and pass the instance to the view.", 
            "title": "Define show method"
        }, 
        {
            "location": "/gettingup/#create-show-file", 
            "text": "Now, create file named  show.html.erb  in  app/views/posts/  with the following content  h1 Show The Post /h1  p \n   strong Title: /strong \n   %= @post.title %  /p  p \n   strong Text: /strong \n   %= @post.text %  /p   And after you submit the form, You'll see the post has been sucessfuly to display.", 
            "title": "Create show file"
        }, 
        {
            "location": "/gettingup/#list-all-post", 
            "text": "So far we just created  new  and  show . But how does we see all these data in one page?. We need to list all our posts, so let's do that by creating  index  method in  posts_controller.rb .  class PostsController   ApplicationController\n\n  def index\n    @post = Post.all\n  end\n\n  #above 'new' method\nend  And create new file named  index  at  app/views/posts/index.html.erb .  h1 Listing Posts /h1  table \n   tr \n     th Title /th \n     th Text /th \n     th /th \n   /tr \n\n   % @post.each do |posts| % \n     tr \n       td %= posts.title % /td \n       td %= posts.text % /td \n       td %= link_to 'Show', post_path(posts) % /td \n     /tr \n   % end %  /table   Then navigate browser to  http://0.0.0.0:3000/posts  You'll see all the post are listed in table with the link to show the post.", 
            "title": "List All Post"
        }, 
        {
            "location": "/gettingup/#add-link", 
            "text": "But we missed a simple thing. We need to add a link to  /posts  view in the root of page. So when user navigate to  http://0.0.0.0:3000 , It will contain a link to  /posts .  Open  app/views/welcome/index.html.erb  and add the link.  h1 Hello, world!! /h1  %= link_to 'My Post', controller: 'posts' %   The  link_to  method is one of Rails built-in view helpers. It create hyperlink based on text to display and where to go.  Next add another link called \"New Post\" in  app/viewws/posts/index.html.erb  placing it above the  table  tag.  %= link_to 'New Post', new_post_path %   Now give a link to back to  /posts  URL in  app/views/posts/new.html.erb  in the bottom of the code.  h1 new Post /h1  %= form_with scope: :post, url: posts_path, local: true do |f|%  p \n   %= f.label :title % br \n   %= f.text_field :title %  /p  p \n   %= f.label :text % br \n   %= f.text_area :text %  /p  p \n   %= f.submit %  /p  % end %  %= link_to 'Back', posts_path %   And finally add another link to go back to posts index in  app/views/posts/show.html.erb .  h1 Show The Post /h1  p \n   strong Title: /strong \n   %= @post.title %  /p  p \n   strong Text: /strong \n   %= @post.text %  /p  %= link_to 'Back', posts_path %", 
            "title": "Add link"
        }, 
        {
            "location": "/gettingup/#update-a-post", 
            "text": "Great. We've covered \"CR\" in the CRUD. Now let's focus on \"U\" part.", 
            "title": "Update a Post"
        }, 
        {
            "location": "/gettingup/#define-edit-method", 
            "text": "The first step is of course to add new method called  edit  in  PostsController . We named it  edit  as the action that covered the URI pattern. Let's show the routes list again for reminder.  $ bin/rails routes\n                   Prefix Verb   URI Pattern                                                                              Controller#Action\n            welcome_index GET    /welcome/index(.:format)                                                                 welcome#index\n                    posts GET    /posts(.:format)                                                                         posts#index\n                          POST   /posts(.:format)                                                                         posts#create\n                 new_post GET    /posts/new(.:format)                                                                     posts#new\n                edit_post GET    /posts/:id/edit(.:format)                                                                posts#edit\n                     post GET    /posts/:id(.:format)                                                                     posts#show\n                          PATCH  /posts/:id(.:format)                                                                     posts#update\n                          PUT    /posts/:id(.:format)                                                                     posts#update\n                          DELETE /posts/:id(.:format)                                                                     posts#destroy\n                     root GET    /                                                                                        welcome#index\n       rails_service_blob GET    /rails/active_storage/blobs/:signed_id/*filename(.:format)                               active_storage/blobs#show\nrails_blob_representation GET    /rails/active_storage/representations/:signed_blob_id/:variation_key/*filename(.:format) active_storage/representations#show\n       rails_disk_service GET    /rails/active_storage/disk/:encoded_key/*filename(.:format)                              active_storage/disk#show\nupdate_rails_disk_service PUT    /rails/active_storage/disk/:encoded_token(.:format)                                      active_storage/disk#update\n     rails_direct_uploads POST   /rails/active_storage/direct_uploads(.:format)                                           active_storage/direct_uploads#create  You can see at  Controller#Action  column it must be  edit . Let's create the action now.  class PostsController   ApplicationController\n  def edit\n    @posts = Post.find(params[:id])\n  end\nend", 
            "title": "Define edit method"
        }, 
        {
            "location": "/gettingup/#create-edit-file", 
            "text": "And create new file named  edit.html.erb  in  app/views/posts/  and make it look as follows:  h1 Edit Post /h1  %= form_with(model: @post, local: true) do |form| % \n\n   p \n     %= form.label :title % br \n     %= form.text_field :title % \n   /p \n\n   p \n     %= form.label :text % br \n     %= form.text_area :text % \n   /p \n\n   p \n     %= form.submit % \n   /p  % end %  %= link_to 'Back', articles_path %   The view contain a form similiar to the one we used to create new post. This time we point the form to the  update  action, which is not defined yet but will be very soon.  Passing the article object to the method, will automagically create url for submitting the edited post form. This option tells Rails that we want this form to be submitted via the PATCH HTTP method which is the HTTP method you're expected to use to update resources according to the REST protocol.  The arguments to  form_with  could be model objects, say,  model: @article  which would cause the helper to fill in the form with the fields of the object. Passing in a symbol  scope  ( scope: :article ) just creates the fields but without anything filled into them.  And don't forget to add the  update  link in  show  and  index  page.  h1 Show The Post /h1  p \n   strong Title: /strong \n   %= @post.title %  /p  p \n   strong Text: /strong \n   %= @post.text %  /p  %= link_to 'Edit', edit_post_path(@post) %  | %= link_to 'Back', posts_path %   for  index  you can add link after  show  link insert  td  tag.  td %= link_to 'Edit', edit_post_path(posts) % /td", 
            "title": "Create edit file"
        }, 
        {
            "location": "/gettingup/#define-update-method", 
            "text": "After that you must create  update  method.    def update\n    @post = Post.find(params[:id])\n\n    if @post.update(post_params)\n      redirect_to @post\n    else\n      render 'edit'\n    end\n  end  The new method  update , is used when you want to update a record that already exists and it accepts a hash containing the attributes that you want to update. As before, if there was an error updating the article we want to show the form back to user. If you noticed that, we reuse  post_params  method that we defined earlier for create action.  After that you'll look your app like this.", 
            "title": "Define update method"
        }, 
        {
            "location": "/gettingup/#delete-post", 
            "text": "So far we just created \"C\", \"R\", and \"U\". The last is the \"D\" AKA Delete. Why we need to delete the post that already created?. Because CRUD is a basic practical method for web development. And the data sometime is growing much bigger than before so we need to delete some data that no longer used.", 
            "title": "Delete Post"
        }, 
        {
            "location": "/gettingup/#define-delete-and-add-action", 
            "text": "Following the REST convention, the route for deleting posts as per output of  bin/rails routes  is  DELETE /posts/:id(.:format) posts#destroy  the  delete  routing method should be used for routes that destroy the resources. We use the  delete  method for destroying resources, and this route is mapped to the  destroy  action inside  app/controllers/posts_controller.rb . Let's create it now at the top of private method.    def destroy\n    @post = Post.find(params[:id])\n    @post.destroy\n\n    redirect_to @post\n  end  Now call  destroy  on Active Record objects when you want to delete them from the database. We dont need to add a view for this action since we're redirecting to the  index  action.  Add 'Destroy' link to your  index  template. Add it wrapped wtith  td  tag and below the  edit  link.  h1 Listing Posts /h1  %= link_to 'New Post', new_post_path %  table \n   tr \n     th Title /th \n     th Text /th \n     th /th \n   /tr \n\n   % @post.each do |posts| % \n     tr \n       td %= posts.title % /td \n       td %= posts.text % /td \n       td %= link_to 'Show', post_path(posts) % /td \n       td %= link_to 'Edit', edit_post_path(posts) % /td \n       td %= link_to 'Destroy', post_path(posts),\n              method: :delete,\n              data: { confirm: 'Are you sure?' } % /td \n     /tr \n   % end %  /table   The  delete  link is little bit different. The  method: :delete  and  data: { confirm: 'Are you sure?' }  options are used as HTML5 attributes so, when the link is clicked, Rails will first show the confirm message to the user, and then submit the link with method  delete .  Good work. You finised the CRUD operation in this section.", 
            "title": "Define delete and add action"
        }, 
        {
            "location": "/validation/", 
            "text": "Adding The Validation\n\n\nIf you look at \"Create\" at CRUD section, the operation seems to run normally. But you missed something that very important. You'll know that if you submit the form without fill it. And your post will look like this.\n\n\n\n\nAnd also your list Posts will look like this.\n\n\n\n\nHow does the form is passing away the empty data to the database?. That's why you need some validation for this.\n\n\nValidate the model\n\n\nTo do the basic validation, open the model of \npost.rb\n model at \napp/models/\n.\n\n\nclass Post \n ApplicationRecord\nend\n\n\n\n\nNote that \nPost\n class inherits from \nApplicationRecord\n. And \nApplicationRecord\n inherits from \nActiveRecord::base\n which supplies a great deal of functionality to your Rails models like basic database CRUD (Create, Read, Update, Delete), operations, data validation, search support, and the ability to relate multiple models to one another.\n\n\nLet's add a basic validation at \nPost\n model.\n\n\nclass Post \n ApplicationRecord\n  validates :title, presence: true,\n                    length: {minimum: 5}\nend\n\n\n\n\nThe validation tell that all posts have a title at least five character long. With this validation, when you call \n@post.save\n on an invalid post, it will return \nfalse\n. Next we need to set the condition at \nnew\n method if \n@post.save\n fails it will show the form back to the user.\n\n\n  def create\n    @post = Post.new(post_params)\n\n    if @post.save\n      redirect_to @post\n    else\n      render 'new'\n    end\n  end\n\n\n\n\nTell the error\n\n\nNow the validation it's working. You can try it by submit a new blank post. It will return back the form since you don't fill up the form but it's not very helpful at all. We need to tell the user why we bring the form back. To do that open the \napp/views/posts/new.html.erb\n and let's add some code.\n\n\n%= form_with scope: :post, url: posts_path, local: true do |f|%\n\n\n\n% if @post.errors.any? %\n\n  \ndiv id=\nerror_explaination\n\n    \nh2\n\n      \n%= pluralize(@post.errors.count, \nerror\n) %\n\n      Prohibited this article from being saved:\n    \n/h2\n\n    \nul\n\n      \n% @post.errors.full_messages.each do |msg| %\n\n        \nli\n%= msg %\n/li\n\n      \n% end %\n\n    \n/ul\n\n  \n/div\n\n\n% end %\n\n\n\n\n\nAt the code, we check if there are any errors with \n@post.errors.any?\n and in that case we show a list of all errors with \n@post.errors.full_messages\n.\n\npluralize\n is a rails helper that takes a number and string as it arguments. If the number is greater than one, the string will be automatically pluralized.\n\n\nNow if you submit the blank form, You will send back to the form and error information as well.", 
            "title": "Validation"
        }, 
        {
            "location": "/validation/#adding-the-validation", 
            "text": "If you look at \"Create\" at CRUD section, the operation seems to run normally. But you missed something that very important. You'll know that if you submit the form without fill it. And your post will look like this.   And also your list Posts will look like this.   How does the form is passing away the empty data to the database?. That's why you need some validation for this.", 
            "title": "Adding The Validation"
        }, 
        {
            "location": "/validation/#validate-the-model", 
            "text": "To do the basic validation, open the model of  post.rb  model at  app/models/ .  class Post   ApplicationRecord\nend  Note that  Post  class inherits from  ApplicationRecord . And  ApplicationRecord  inherits from  ActiveRecord::base  which supplies a great deal of functionality to your Rails models like basic database CRUD (Create, Read, Update, Delete), operations, data validation, search support, and the ability to relate multiple models to one another.  Let's add a basic validation at  Post  model.  class Post   ApplicationRecord\n  validates :title, presence: true,\n                    length: {minimum: 5}\nend  The validation tell that all posts have a title at least five character long. With this validation, when you call  @post.save  on an invalid post, it will return  false . Next we need to set the condition at  new  method if  @post.save  fails it will show the form back to the user.    def create\n    @post = Post.new(post_params)\n\n    if @post.save\n      redirect_to @post\n    else\n      render 'new'\n    end\n  end", 
            "title": "Validate the model"
        }, 
        {
            "location": "/validation/#tell-the-error", 
            "text": "Now the validation it's working. You can try it by submit a new blank post. It will return back the form since you don't fill up the form but it's not very helpful at all. We need to tell the user why we bring the form back. To do that open the  app/views/posts/new.html.erb  and let's add some code.  %= form_with scope: :post, url: posts_path, local: true do |f|%  % if @post.errors.any? % \n   div id= error_explaination \n     h2 \n       %= pluralize(@post.errors.count,  error ) % \n      Prohibited this article from being saved:\n     /h2 \n     ul \n       % @post.errors.full_messages.each do |msg| % \n         li %= msg % /li \n       % end % \n     /ul \n   /div  % end %   At the code, we check if there are any errors with  @post.errors.any?  and in that case we show a list of all errors with  @post.errors.full_messages . pluralize  is a rails helper that takes a number and string as it arguments. If the number is greater than one, the string will be automatically pluralized.  Now if you submit the blank form, You will send back to the form and error information as well.", 
            "title": "Tell the error"
        }
    ]
}